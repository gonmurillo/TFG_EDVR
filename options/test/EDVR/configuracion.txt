name: EDVR_L_x4_REDS_SRblur_official
model_type: EDVRModel
scale: 4
num_gpu: 4 
manual_seed: 0

# name:os cambiar el nombre que le queremos dar a la ejecución
# model:el modelo siempre será el mismo ya que solo trabajamos con EDVR en BasicSR.
# scale: es la escala de la salida respecto a la entrada, el upsampling ratio.
# num_gpu: en todas nuestras ejecuciones el número de Gpu's es una por nustras limitaciones hardware, que se indica por 
#          parametro.

datasets:
  test:
    name: REDS4
    type: VideoTestDataset
    dataroot_gt: datasets/REDS/train_sharp/train/train_sharp
    dataroot_lq: datasets/REDS/train_blur_bicubic/train/train_blur_bicubic/X4
    meta_info_file: basicsr/data/meta_info/meta_info_REDS4_test_GT.txt
    io_backend:
      type: disk

    cache_data: false
    num_frame: 5
    padding: replicate

# name: el nombre del dataset.
# type: es el tipo de dataset que se usa, depende de la estructura de los dataset, en nuestros casos se usan dos:
#     video_test_dataset: 
#                            dataroot
#                            ├── subfolder1
#                                ├── frame000
#                                ├── frame001
#                                ├── ...
#                            ├── subfolder1
#                                ├── frame000
#                                ├── frame001
#                                ├── ...
#                            ├── ...
#
#    vimeo90k_dataset:  1. clip name; 2. frame number; 3. image shape, seperated by a white space.
# 
# dataroot_gt: path a las imágenes originales.
# dataroot_lq: path a las imágenes en baja calidad.
# meta_info_file: el fichero con la estructura de los datasets.
# io_backend: Hay tres opciones para la ejecución disk, LMDB o memcached, solo se ha usdo disk para nustros experimentos.
# padding: replicate o reflection_circle, son dos técnicas para conseguir que durante el procesamiento el tamaño de las 
#          imágenes no cambie.

network_g:
  type: EDVR
  num_in_ch: 3
  num_out_ch: 3
  num_feat: 128
  num_frame: 5
  deformable_groups: 8
  num_extract_block: 5
  num_reconstruct_block: 40
  center_frame_idx: ~
  hr_in: false
  with_predeblur: true
  with_tsa: true

# type: tipo de arquitectura que se usa, solo usaremos EDVR.
# with_predeblur: tenemos la opción de activar o desactivar la opción de desemborronado previo. 
# with_tsa: tenemos la opción de activar o desactivar la opción de TSA de fusion de frames, aunque es una de las 
#           funcionalidades básicas de EDVR.

path:
  pretrain_network_g: experiments/pretrained_models/EDVR/EDVR_L_x4_SRblur_REDS_official-983d7b8e.pth
  strict_load_g: true

#  pretrain_network_g: path al modelo preentrenado.
#  strict_load_g: tenemos la opción de usarlo o no.

val:
  save_img: true
  suffix: ~  
  
# save_img: decide si se guardan las imágenes durante la validación.


  metrics:
    psnr: y
      type: calculate_psnr
      crop_border: 0
      test_y_channel: false

# Metricas extra que calculan el PSNR(Peak Signal-to-Noise Ratio)